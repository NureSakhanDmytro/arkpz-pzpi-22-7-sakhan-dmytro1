Міністерство освіти і науки Украї¨ни Харківськии˘ національнии˘ університет радіоелектроніки
Кафедра програмної¨ інженерії¨ Звіт ЛБ №4
З Аналіз та рефакторинг коду
На тему «ЛАБОРАТОРНА РОБОТА №4. РОЗРОБКА IoT КЛІЄНТА (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)»




Виконав:	        Перевірив:


студент групи ПЗПІ-22-7	кафедри ПІ
Сахань Дмитро Олександрович	Сокорчук Ігор Петрович












Харків 2023
 
ЛАБОРАТОРНА РОБОТА №4. РОЗРОБКА IoT КЛІЄНТА (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)


4.1	Мета роботи



Розробити програмне забезпечення для IoT або SmartDevice пристрою, створеного на базі будь-якої поширеної на сьогодні платформи, придатної для реалізації вбудованих систем.



4.2	Хід роботи
4.2.1	Опис інженерних рішень



Архітектура IoT-клієнта побудована на основі модульного підходу, що дозволяє розподіляти функціональність між окремими компонентами.
Основними складовими є графічний інтерфейс користувача, симулятор даних сенсорів та протокол клієнт-серверної взаємодії. Графічний інтерфейс відповідає за зручну взаємодію з користувачем, дозволяє налаштовувати параметри, такі як формат дати, часова зона та система мір, а також управляти симуляцією і відслідковувати аварійні стани. Симулятор даних генерує випадкові показники сенсорів, включаючи температуру, вологість, вагу і стан грунта. Забезпечуючи передачу даних у реальному часі.
IoT-клієнт взаємодіє із сервером, що забезпечує універсальність і зручність. Перед відправкою дані проходять валідацію для гарантії їхньої коректності.
Бізнес-логіка IoT-клієнта включає математичну обробку даних для аналізу стану ліфта та генерації критичних подій. Показники сенсорів: температура, вологість и тд — аналізуються на відповідність встановленим порогам. У разі перевищення цих значень або виявлення аварійного стану генерується подія типу critical, тоді як у штатному режимі створюються події normal.
 
Інженерні підходи реалізовані через модульність структури, обробку винятків та тестованість компонентів. Логіка програми розділена на модулі. Обробка винятків забезпечує стабільну роботу навіть у разі помилок користувача або проблем із з’єднанням. Розробка здійснювалась із врахуванням можливості модульного тестування.
Запропоновані рішення мають низку переваг. Зручний інтерфейс спрощує використання, гнучкість дозволяє змінювати налаштування без модифікації коду, а масштабованість забезпечує легке додавання нових функцій. Завдяки обробці винятків і перевірці даних клієнт характеризується високою стабільністю.



4.2.2	UML-діаграми

Рисунок 4.1 — UML-діаграма прецедентів ІоТ клієнта
Діаграма прецедентів для IoT-клієнта:
Актори:
•	Користувач: особа або система, що взаємодіє з IoT-клієнтом.
•	IoT-клієнт: програмне забезпечення, що збирає дані від сенсорів, відправляє їх на сервер і отримує рекомендації.
•	Сервер: віддалений сервер, який отримує дані від IoT-клієнта, обробляє їх та повертає відповіді.
 
Прецеденти:
1.	Запит даних від сенсора:
o	Користувач ініціює запит для збору даних від сенсора.
o	IoT-клієнт збирає дані з відповідного сенсора.
2.	Відправка даних на сервер:
o	Коли дані зібрані, IoT-клієнт передає їх на сервер для обробки.
3.	Отримання рекомендацій:
o	Після відправлення даних IoT-клієнт може отримати рекомендації або сповіщення від сервера.
4.	Налаштування клієнта:
o	Користувач може налаштувати IoT-клієнт, наприклад, вибрати сенсори для моніторингу, налаштувати інтервали збору даних або сервер.
5.	Оновлення налаштувань:
o	Користувач може оновити параметри роботи клієнта, змінюючи інтервали збору даних або інші конфігурації.
Опис взаємодії:
1.	Користувач -> IoT-клієнт: Користувач ініціює запит на збір даних або налаштування клієнта.
2.	IoT-клієнт -> Сенсор: IoT-клієнт отримує дані від сенсора.
3.	IoT-клієнт -> Сервер: IoT-клієнт відправляє дані на сервер для обробки.
4.	Сервер -> IoT-клієнт: Сервер обробляє дані та відправляє рекомендації або сповіщення на клієнт.
5.	Користувач -> IoT-клієнт: Користувач може ініціювати налаштування клієнта або оновлення параметрів.
 
Рисунок 4.2 — UML-діаграма діяльності ІоТ-клієнта






4.3	Висновки:
Під час виконання лабораторної роботи було розроблено IoT-клієнт з імітацією праці анализа грунтов та пов’язаних з ними датчиків. Прийняті рішення забезпечують відповідність сучасним вимогам до IoT-клієнтів і дозволяють легко інтегрувати пристрій у більші програмні системи.


Посилання на відеопрезентацію:
https://youtu.be/5IpGqPue0ZQ

Посилання на Github-репозиторій: 
https://github.com/NureSakhanDmytro/arkpz-pzpi-22-7-sakhan-dmytro/blob/main/Task4

Посилання на Github-репозиторій: 
https://github.com/NureSakhanDmytro/arkpz-pzpi-22-7-sakhan-dmytro.git 

ДОДАТОК А: Фрагмент коду, пов’язаного з бізнес-логікою IoT-клієнта
У цьому фрагменті коду представлена бізнес-логіка IoT-клієнта, яка відповідає за збір та обробку даних від сенсорів, передавання даних на сервер та обробку отриманих рекомендацій.


using System;
using System.Net.Http; using System.Text;
using System.Threading.Tasks;


namespace IoTClient
{
public class IoTClientBusinessLogic
{
private readonly HttpClient _httpClient;


public IoTClientBusinessLogic()
{
_httpClient = new HttpClient();
}


// Метод для збору даних від сенсорів
public async Task<string> CollectSensorDataAsync(string sensorType)
{
// Симуляція збору даних від сенсора
string sensorData = $"{{ \"sensor\": \"{sensorType}\", \"value\": {new Random().Next(1, 100)} }}";
 
Console.WriteLine($"Зібрано дані від сенсора {sensorType}:
{sensorData}");


return sensorData;
}


// Метод для відправки даних на сервер
public async Task SendDataToServerAsync(string data)
{
string serverUrl = "https://example.com/api/submit_data";


var content = new StringContent(data, Encoding.UTF8, "application/json");


try
{
var response = await _httpClient.PostAsync(serverUrl, content); if (response.IsSuccessStatusCode)
{
Console.WriteLine("Дані успішно відправлені на сервер.");
}
else
{
Console.WriteLine("Не вдалося відправити дані на сервер.");
}
}
catch (Exception ex)
{
 
Console.WriteLine($"Помилка під час відправки даних на сервер:
{ex.Message}");
}
}


// Метод для отримання рекомендацій від сервера public async Task<string> GetRecommendationsAsync()
{
string serverUrl = "https://example.com/api/get_recommendations";


try
{
var response = await _httpClient.GetStringAsync(serverUrl); Console.WriteLine($"Отримано рекомендації: {response}"); return response;
}
catch (Exception ex)
{
Console.WriteLine($"Помилка при отриманні рекомендацій:
{ex.Message}");
return null;
}
}
}
}


Опис коду:
 
CollectSensorDataAsync — збір даних від сенсорів (симуляція).
SendDataToServerAsync — відправка зібраних даних на сервер за допомогою HTTP POST запиту.
GetRecommendationsAsync — отримання рекомендацій від сервера на основі зібраних даних.





ДОДАТОК Б: Фрагмент коду, пов’язаного з налаштуванням IoT-клієнта
У цьому фрагменті коду реалізується налаштування IoT-клієнта, зокрема підключення до сервера, ініціалізація сенсорів та інших параметрів.
using System;
using System.Collections.Generic;


namespace IoTClient
{
public class IoTClientSetup
{
public List<string> Sensors { get; set; } public string ServerUrl { get; set; } public int DataInterval { get; set; }

public IoTClientSetup()
{
Sensors = new List<string> { "Temperature", "Humidity", "SoilMoisture"
};
ServerUrl = "https://example.com/api";
DataInterval = 10000; // інтервал збору даних у мілісекундах
 
}


// Метод для налаштування IoT-клієнта public void SetupClient()
{
Console.WriteLine("Налаштовуємо IoT-клієнта...");


// Підключення до сервера ConnectToServer(ServerUrl);

// Ініціалізація сенсорів foreach (var sensor in Sensors)
{
Console.WriteLine($"Ініціалізація сенсора: {sensor}");
}

// Налаштування інтервалу збору даних Console.WriteLine($"Інтервал збору даних: {DataInterval / 1000}
секунд");
}


// Метод для підключення до сервера
private void ConnectToServer(string serverUrl)
{
Console.WriteLine($"Підключення до сервера за адресою:
{serverUrl}");


// Симуляція підключення до сервера
 
// В реальному застосуванні тут можна додати код для встановлення реального з'єднання
}
}
}


Опис коду:


Sensors — список сенсорів, які використовуються в IoT-клієнті. ServerUrl — URL сервера для передачі та отримання даних.
DataInterval — інтервал часу для збору даних від сенсорів.
SetupClient — метод для налаштування клієнта, підключення до сервера та ініціалізації сенсорів.
Загальна ідея налаштувань:


Перш за все налаштовується підключення до сервера.
Далі ініціалізуються сенсори, які будуть використовуватись для збору даних.
Встановлюється інтервал, через який буде відбуватись збір даних від сенсорів.
Ці два фрагменти коду описують основні функціональні можливості IoT- клієнта, від збору даних до їх відправлення на сервер та отримання рекомендацій.
